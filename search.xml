<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React Hooks 入门</title>
      <link href="/2019/09/03/reacthooks/"/>
      <url>/2019/09/03/reacthooks/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">React Hooks</a> 是 React v16.8 版本中引入的新特性，阅读本文需要一定的 React 基础。</p><h2 id="一、Hooks-出现的原因"><a href="#一、Hooks-出现的原因" class="headerlink" title="一、Hooks 出现的原因"></a>一、Hooks 出现的原因</h2><p>React 的核心是组件。v16.8 版本之前，组件的标准写法是类，还有一种就是函数式组件或者(说是无状态组件)。</p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>下面是一个简单的类组件示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;点击了 &#123; <span class="keyword">this</span>.state.count &#125; 次&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123; this.addCount.bind(this) &#125;&gt;确定&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  addCount() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123; count: this.state.count+1 &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">export default Demo;</span></span><br></pre></td></tr></table></figure><p>组件类的几个缺点：</p><ul><li>大型组件很难拆分和重构，也很难测试。</li><li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li></ul><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>要求必须是一个纯函数，不能包含状态，不支持生命周期方法。</p><h3 id="React-Hooks-设计目的"><a href="#React-Hooks-设计目的" class="headerlink" title="React Hooks 设计目的"></a>React Hooks 设计目的</h3><p>所以 React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。 </p><h2 id="二、Hook-的含义"><a href="#二、Hook-的含义" class="headerlink" title="二、Hook 的含义"></a>二、Hook 的含义</h2><p>Hook 这个单词的意思是”钩子”。<br>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。</p><p>所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p><p>下面介绍 React 默认提供的四个最常用的钩子。</p><ul><li>useState()</li><li>useContext()</li><li>useReducer()</li><li>useEffect()</li></ul><h2 id="三、useState-：状态钩子"><a href="#三、useState-：状态钩子" class="headerlink" title="三、useState()：状态钩子"></a>三、useState()：状态钩子</h2><p>useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p><p>本文前面那个组件类，用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用useState()重写如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, addCount ] = useState(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;点击了 &#123; count &#125; 次&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;&#123; addCount(count+1) &#125;&#125;&gt;确定&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Demo;</span></span><br></pre></td></tr></table></figure><p>useState() 函数接受状态的初始值，作为参数，上例的初始值为要展示的数值0。该函数返回一个长度为2的数组，数组的第一个值是一个变量（上例是count），指向状态的当前值。第二个值是一个函数，用来更新状态。</p><p><strong> useState 使用注意 </strong><br>useState 的执行顺序在每一次更新渲染时必须保持一致，否则多个 useState 调用将不会得到各自独立的状态，也会造成状态对应混乱。比如在条件判断中使用 hook，在循环，嵌套函数中使用 hook，都会造成 hook 执行顺序不一致的问题。最后导致状态的混乱。另外，所有的状态声明都应该放在函数顶部，首先声明。</p><h2 id="四、useContext-：共享状态钩子"><a href="#四、useContext-：共享状态钩子" class="headerlink" title="四、useContext()：共享状态钩子"></a>四、useContext()：共享状态钩子</h2><p>如果需要在组件之间共享状态，可以使用useContext()。</p><p>现在有两个组件 Navbar 和 Messages，我们希望它们之间共享状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个共享状态</span></span><br><span class="line"><span class="keyword">const</span> UserContext = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Navbar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// useContext() 钩子函数用来引入 Context 对象，从中获取username属性。</span></span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(UserContext)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;A 组件里的用户：&#123; username &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Messages = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ useContext() 钩子函数用来引入 Context 对象，从中获取username属性。</span></span><br><span class="line"><span class="regexp">  const &#123; username &#125; = useContext(UserContext)</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;B 组件里的用户：&#123; username &#125;&lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// UserContext.Provider提供了一个 Context 状态共享对象，这个对象可以被子组件共享。</span></span><br><span class="line">    &lt;UserContext.Provider value=&#123;&#123; <span class="attr">username</span>: <span class="string">'PAN~~~'</span> &#125;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Navbar /&gt;</span><br><span class="line">        &lt;Messages /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>UserContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="五、useReducer-：action-钩子"><a href="#五、useReducer-：action-钩子" class="headerlink" title="五、useReducer()：action 钩子"></a>五、useReducer()：action 钩子</h2><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p><p>Redux 的核心概念是，组件发出 action 与状态管理器通信(store)。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，然后再返回给状态 管理通信器，Reducer 函数的形式是(state, action) =&gt; newState。</p><p>useReducers()钩子用来引入 Reducer 功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure><p>useReducer() 接收 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的 dispatch 函数。</p><p>下面看一个简单的计数器效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于计算状态的 Reducer 函数</span></span><br><span class="line"><span class="keyword">const</span> myReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">'countUp'</span>):</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(myReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'countUp'</span> &#125;)&#125;&gt;</span><br><span class="line">        +<span class="number">1</span></span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Count: &#123;state.count&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><h2 id="六、useEffect-：副作用钩子"><a href="#六、useEffect-：副作用钩子" class="headerlink" title="六、useEffect()：副作用钩子"></a>六、useEffect()：副作用钩子</h2><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。具体用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>  =&gt;</span>  &#123;</span><br><span class="line">  <span class="comment">// Async Action</span></span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure><p>上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。</p><p><strong> 注意 </strong><br>第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</p><p>下面看一下实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">&#123; personId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://easy-mock.com/mock/5d53bf7452cb451e4e23fd53/study/getPerson?id=<span class="subst">$&#123;personId&#125;</span>`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'First Loading...'</span>)</span><br><span class="line">        setPerson(data.data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);</span><br><span class="line">  <span class="comment">// 每当组件参数personId发生变化，useEffect()就会执行。</span></span><br><span class="line">  <span class="comment">// 组件第一次渲染时，useEffect()也会执行。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Loading ...&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名: &#123;person.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;年龄: &#123;person.age&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  const [show, setShow] = useState("1");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div className="App"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Person personId=&#123;show&#125; /</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setShow(<span class="string">"1"</span>)&#125;&gt;Person <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setShow("2")&#125;&gt;Person 2&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="七、创建自己的-Hooks"><a href="#七、创建自己的-Hooks" class="headerlink" title="七、创建自己的 Hooks"></a>七、创建自己的 Hooks</h2><p>下面的示例以上面的例子为基础，自定义一个 Hooks，usePerson()就是一个自定义的 Hook。</p><p>Person 组件就改用这个新的钩子，引入封装的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usePerson = <span class="function"><span class="params">personId</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://easy-mock.com/mock/5d53bf7452cb451e4e23fd53/study/getPerson?id=<span class="subst">$&#123;personId&#125;</span>`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        setPerson(data.data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);</span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="keyword">return</span> [loading, person];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">&#123; personId &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, person] = usePerson(personId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Loading ...&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名: &#123;person.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;年龄: &#123;person.age&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  const [show, setShow] = useState("1");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div className="App"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Person personId=&#123;show&#125; /</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setShow(<span class="string">"1"</span>)&#125;&gt;Person <span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setShow("2")&#125;&gt;Person 2&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>（完）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>非微信官方网页，继续访问将转换成手机预览模式</title>
      <link href="/2019/01/24/wechatnoaccess/"/>
      <url>/2019/01/24/wechatnoaccess/</url>
      
        <content type="html"><![CDATA[<p>你的网站如果没有在公众后台设置JS接口安全域名的话会提示“非微信官方网页，继续访问将转换成手机预览模式”，所以呢先登录你的公众号后台设置一下，设置–&gt;公众号设置–&gt;功能设置–&gt;JS接口安全域名</p><p><img src="http://wx1.sinaimg.cn/large/889d1a94gy1fzhgbe2vcuj20vq09c74r.jpg" alt="image"></p><p><img src="http://wx2.sinaimg.cn/large/889d1a94gy1fzhghbt49vj21pa0r8q5q.jpg" alt="image"></p><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhglivs9vj21sm13i7at.jpg" alt="image"></p><p>点设置后弹窗你会看到几点要求，其中主要的是第二第三点，你的域名是要备案过的，另外需要把 MP_verify_9Ejr0IPEERUl7Xp8.txt 文件下载放至你的服务器或者空间根目录下，最后添加你的站点域名，如果通过 <a href="http://www.xxx.com/MP_verify_9Ejr0IPEERUl7Xp8.txt" target="_blank" rel="noopener">www.xxx.com/MP_verify_9Ejr0IPEERUl7Xp8.txt</a> 能访问到这个文件，在添加域名之后一般是能保存成功的，会有相应的提示。</p><p>注：<br>1、如果还没备案的话提交备案到完成可能至少要六七天的时间估计，但也是不确定的具体要看相应的情况，而且备案完成后还需要等待1-3天才能查询得到你的备案信息。<br>2、因为我的只是个人订阅号，所以只有 JS接口安全域名这一项，如果是认证的账号还会有业务域名和网页授权域名。</p><p>添加成功后你的站点就能正常的在微信内打开了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 入门篇</title>
      <link href="/2019/01/22/nginxbase/"/>
      <url>/2019/01/22/nginxbase/</url>
      
        <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>支持高并发</li><li>内存消耗少</li><li>开源可商用</li></ol><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><strong>Mac 下安装</strong><br>1、安装 brew 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>2、安装 Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure></p><p>3、启动 Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></p><p>如果没有报错的话打开 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 就可以看到效果了。</p><p>配置文件所在目录 /usr/local/etc/nginx/nginx.conf</p><p>安装文件所在目录 /usr/local/Cellar/nginx</p><p><strong>Linux 下安装（本文后面的内容也主要是在 Centos 环境中演示）</strong><br>先安装一些服务器要用到的东西<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf pcre-devel make automake</span><br><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure></p><p>查看 yum 是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p>如果存在会如以下图示</p><p><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fzf7pigjyjj20mr08fabf.jpg" alt="image"></p><p>和官网的对比一下发现不是最新的，所以要增加 nginx 的 yum 源，输入以下命令新建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>并把以下内容粘贴进去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>因为我的是 centos 系统，版本是7.2，所以链接里面是 /centos/7，现在再运行一下检查命令就可以查看到最新 nginx 版本了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p>接着就是安装了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>安装完成后输入 <font color="#f60">nginx -v</font> 查看版本号，如果显示版本就表示安装成功了</p><p><img src="http://ws4.sinaimg.cn/large/889d1a94gy1fzf88dbsxnj20ng0e140b.jpg" alt="image"></p><h2 id="二、Nginx-配置文件解析"><a href="#二、Nginx-配置文件解析" class="headerlink" title="二、Nginx 配置文件解析"></a>二、Nginx 配置文件解析</h2><h2 id="三、启动、停止、重启等常用操作"><a href="#三、启动、停止、重启等常用操作" class="headerlink" title="三、启动、停止、重启等常用操作"></a>三、启动、停止、重启等常用操作</h2><p><strong>启动</strong><br>1、直接使用 nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></p><p>2、使用 systemctl 命令，这个是 Linux 的服务启动命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure></p><p>有没有启动成功呢？可以输入以下命令查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure></p><p><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzfeh1ugvwj20nc02baab.jpg" alt="image"></p><p><strong>停止</strong><br>1、立即停止服务。这种方法无论进程是否在运行，都直接停止进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx  -s stop</span><br></pre></td></tr></table></figure></p><p>2、立即停止服务。这种方法相对没那么强硬，需要在进程完成当前工作后再停止。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx  -s quit</span><br></pre></td></tr></table></figure></p><p>3、killall 直接杀死进程。如果上面的两个方法无效，可以试试这个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure></p><p>4、systemctl 停止。这个和启动方法中第二条类似，都是使用 Linux 的服务命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx.service</span><br></pre></td></tr></table></figure></p><p><strong>重启</strong><br>重启也是经常会用到的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure></p><p><strong>重载配置文件</strong><br>有时修改了配置文件可以不用重启，直接重载配置文件就可以了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></p><p><strong>查看端口号</strong><br>有时候需要查看哪些端口在运行，或者被占用了，可以使用 netstat 命令查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure></p><h2 id="四、自定义错误页"><a href="#四、自定义错误页" class="headerlink" title="四、自定义错误页"></a>四、自定义错误页</h2><p><strong>自定义错误页</strong><br>网站发生错误时一般会返回相应的状态码，比如500、502、503等等，或者404页面。那这些对应的返回页面在 Nginx 里怎么配置呢。</p><p>进入 /etc/nginx/conf.d 目录 打开 default.conf 配置文件就可以作相应的修改了</p><p><img src="http://ws1.sinaimg.cn/large/889d1a94gy1fzfg3vng9pj20n5027aa3.jpg" alt="image"></p><p>添加404页面配置，当然你还要在网站根目录创建一个404.html页面才行</p><p><img src="http://wx1.sinaimg.cn/large/889d1a94gy1fzfged7tgjj20nu0i876t.jpg" alt="image"></p><p>其中 /404.html 也可以改成一个链接地址如： (<a href="https://pojian.xyz)[https://pojian.xyz]，这样当你访问为404状态时就会直接跳转到你配置的这个链接地址。">https://pojian.xyz)[https://pojian.xyz]，这样当你访问为404状态时就会直接跳转到你配置的这个链接地址。</a></p><p>最后还需要你执行重载配置文件或者重启服务器，再访问相应的页面就会看到对应的效果页。</p><h2 id="五、访问权限设置"><a href="#五、访问权限设置" class="headerlink" title="五、访问权限设置"></a>五、访问权限设置</h2><p><strong>指令优先级</strong><br>打开配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></p><p>在 location 里填写 deny 和 allow 配置信息，deny 和 allow 后面可以填写 ip 或者一个 ip 段，再或者 all，all 表示全部，比如这里我填写的是我本机的ip，allow 表示允许该 ip 的访问，接着重启 nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fzgkp66ohwj219e0dugmz.jpg" alt="image"></p><p>上面的配置表示只允许 113.118.186.11 进行访问，其他的IP是禁止访问</p><p><img src="http://ws2.sinaimg.cn/large/889d1a94gy1fzgl1ra9b1j21jg076jrr.jpg" alt="image"></p><p>如果上面的 allow 和 deny 位置互换一下呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deny all;</span><br><span class="line">allow 113.118.186.11;</span><br></pre></td></tr></table></figure><p>这里你会发再所有 ip 都不能访问了，这就说明了配置对顺序是有要求的，同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置。</p><p><strong>其他访问控制权限匹配</strong><br>有时权限控制会比上面的情况会多样一点，比如站点下的 images 文件是所有用户都可以访问的，而 admin 文件夹只有管理员才能访问，这时就需要 location 来配合实现了</p><h2 id="六、配置虚拟主机"><a href="#六、配置虚拟主机" class="headerlink" title="六、配置虚拟主机"></a>六、配置虚拟主机</h2><p><strong>基于端口号</strong><br>基于端口号配置多个虚拟主机，根据不同的端口号来访问不同的站点，原来就是监听端口号。</p><p>可以直接配置了主配置文件 etc/nginx/nginx.conf，也可以配在子配置文件目录下 etc/nginx/conf.d，这里拿配置在子文件做示例</p><p>etc/nginx/conf.d/default.conf 默认监听的是 <strong>80</strong> 端口，指向的目录是 /data/www</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhod50ihzj21660bct9n.jpg" alt="image"></p><p>现在我们配置添加一个新的虚拟主机，监听 <strong>8081</strong> 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/8081.conf</span><br></pre></td></tr></table></figure><p>8081.conf 具体配置如下，监听的端口为 <strong>8081</strong>，指向的目录是 /data/www/8081，和 <strong>80</strong> 端口指向的目录不一样</p><p><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzhoi9spuxj216i04wdg7.jpg" alt="image"></p><p>这里需要你自己去新建一个 8081 目录和 index.html 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/www/8081</span><br><span class="line">vim /data/www/8081/index.html</span><br></pre></td></tr></table></figure><p>最后访问 xxx.com 和 xxx.com:8081 会访问到不同的站点，当然前提是你的域名已经解析到你的服务器，要不然的话就只能通过 ip 访问了 xxx.xxx.xx.xx 和 xxx.xxx.xx.xx:8081 访问。</p><p><strong>基于域名配置</strong></p><p>基于域名配置，我这里先说一个前提，就是你的域名已经成功解析到服务器。</p><p><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fzhosuczh6j21u2080jsw.jpg" alt="image"></p><p>下面开始配置 nginx</p><p>/etc/nginx/conf.d/default.conf 配置文件监听的是 <strong>80</strong> 端口，指向目录是 /data/www，注意看 server_name 改成域名地址</p><p><img src="http://wx2.sinaimg.cn/large/889d1a94gy1fzhobuxtkxj21660bcdgt.jpg" alt="image"></p><p>接着我们来配置另外一个虚拟站点 /etc/nginx/conf.d/8081.conf，注意了 这里监听我端口也是 <strong>80</strong> 端口，不是其他的端口号，但 server_name 和 root 目录跟上面的不一样</p><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhshp7dttj216405ogm3.jpg" alt="image"></p><p>这样当你访问 nginx.pojian.xyz 和 nginx2.pojian.xyz 时访问会是配置的不同的两个站点。</p><h2 id="七、反向代理"><a href="#七、反向代理" class="headerlink" title="七、反向代理"></a>七、反向代理</h2><p><strong>正向代理</strong><br>A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。</p><p>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>  时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。<br><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzittlk5sgj20zu0kq1kx.jpg" alt="image"></p><p><strong>反向代理</strong></p><p>大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。</p><p>反向代理隐藏了真实的服务端，当我们请求<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，具体访问哪台服务器Server是由Nginx来控制的，一般用来做负载均衡。</p><p><img src="http://ws2.sinaimg.cn/large/889d1a94gy1fzitu7g08oj20sk0nk7pb.jpg" alt="image"></p><p>两者的区别在于代理的对象不一样：<strong>正向代理代理的对象是客户端，反向代理代理的对象是服务端</strong></p><p><strong>最简单的反向代理</strong></p><p>下面就说一个最简单的反向代理配置，先打开我们前面配置的 8081 端口虚拟站点配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/8081.conf</span><br></pre></td></tr></table></figure><p><img src="http://ws3.sinaimg.cn/large/889d1a94gy1fzhshp7dttj216405ogm3.jpg" alt="image"></p><p>原来的 root 和 index 不要了，换成一个 location 代理地址，看下图</p><p><img src="http://wx2.sinaimg.cn/large/889d1a94gy1fziv0a4rtyj21cs05udk2.jpg" alt="image"></p><p>这样当你访问 nginx2.pojian.xyz 的时候 nginx 会帮你反向代理到 <a href="https://pojian.xyz">https://pojian.xyz</a> 这个地址上去，proxy_pass 一般是填写 ip，但填写域名也可以。</p><p><strong>其它一些较常用的反向代理指令</strong></p><ul><li>proxy_set_header: 在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</li><li>proxy_connect_timeout: 配置Nginx与后端代理服务器尝试建立连接的超时时间。</li><li>proxy_read_timeout: 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。</li><li>proxy_send_timeout: 配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。</li><li>proxy_redirect: 用于修改后端服务器返回的响应头中的Location和Refresh。</li></ul><h2 id="八、开启-Gzip-压缩"><a href="#八、开启-Gzip-压缩" class="headerlink" title="八、开启 Gzip 压缩"></a>八、开启 Gzip 压缩</h2><p>Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。</p><ul><li>gzip : 该指令用于开启或 关闭gzip模块。</li><li>gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。</li><li>gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li><li>gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。</li><li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。</li><li>gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0.</li><li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。</li><li>gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。</li></ul><p>最简单的配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    .....</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types text/plain application/javascript text/css;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://wx4.sinaimg.cn/large/889d1a94gy1fzixy8p8c4j21820eogsb.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Mac下SSH闲时自动断开的问题</title>
      <link href="/2019/01/22/macsshconnection/"/>
      <url>/2019/01/22/macsshconnection/</url>
      
        <content type="html"><![CDATA[<p>使用 Mac 自带终端 SSH 连接服务器时，只要隔一小段时间不进行操作的话连接就会自动中断，造成了不好的体验。解决方法如下：</p><p>1、连接到你的服务器</p><p>2、编辑服务端配置文件 /etc/ssh/sshd_config<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>添加以下两行配置代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 30</span><br><span class="line">ClientAliveCountMax 3</span><br></pre></td></tr></table></figure><p>3、编辑客户端配置文件 /etc/ssh/ssh_config<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure></p><p>在 Host * 下面添加以下两行配置代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval 30</span><br><span class="line">ServerAliveCountMax 3</span><br></pre></td></tr></table></figure></p><p>4、断开SSH连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + d</span><br></pre></td></tr></table></figure></p><p>5、SSH 重连服务然后执行重启<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line">reboot 就是重启</span><br></pre></td></tr></table></figure></p><p>重启后可能需要等待1分钟左右才能重新连接上。</p><p>最后验证测试就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细Hexo+Github Page搭建技术博客教程【持续更新】</title>
      <link href="/2019/01/18/hexo/"/>
      <url>/2019/01/18/hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。</p><p>这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p><p>下面就开始吧~</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>准备 node 和 git 环境，<br>首先，安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a>，因为 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。<br>然后，安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git</a> 教程。</p><p>两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。<br>在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz2nmvl6kej20g907dwet.jpg" alt="image"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 的详细文档。<br>在命令行输入执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line"><span class="built_in">cd</span> myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模版文件夹</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿文件</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章Markdowm文件 </span></span><br><span class="line">└── themes  <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure><p>好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 回车就可以预览效果了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz2r6obbifj21bo0mfdjx.jpg" alt="image"></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。</p><h2 id="注册-Github"><a href="#注册-Github" class="headerlink" title="注册 Github"></a>注册 Github</h2><p>首先如果你还没有 Github 账号的先<a href="https://github.com" target="_blank" rel="noopener">注册</a>一个，具体过程如下</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz2ovhptzgj20n90rk12d.jpg" alt="image"></p><p>点击 Start project 或者下面的 new repository 创建一个新的仓库</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2p5l7j6cj20sk0h8wju.jpg" alt="image"></p><p>注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz2po2plspj20kr0hbtbb.jpg" alt="image"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World.</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz2q91ar2zj20s80e50va.jpg" alt="image"><br><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz2qami35uj20dt06a74t.jpg" alt="image"></p><p>这个时候打开 http://你的用户名.github.io 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 http://你的用户名.github.io 看到你自己的博客啦！ 比如我的就是 <a href="http://webw3c.github.io" target="_blank" rel="noopener">http://webw3c.github.io</a> 了。</p><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz2pwjzahzj20c0040mx4.jpg" alt="image"></p><h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p><p>打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz2rym90u1j20fr03jgm6.jpg" alt="image"></p><p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"邮箱地址"</span></span><br></pre></td></tr></table></figure><p>然后开始生成密钥 SSH key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'上面的邮箱'</span></span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2s3i3zi0j20iz0anq7a.jpg" alt="image"></p><p>（此图引用自码云）</p><p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz2s6m2kjwj20fq01g3yg.jpg" alt="image"></p><p>到这还没完，还要登录 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 上添加刚刚生成的SSH key，按以下步骤添加：</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz2s9u4bi4j205n0as0t0.jpg" alt="image"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2sc8liqmj20sb0c9jtg.jpg" alt="image"></p><h2 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h2><p>此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">部署</a>教程。<br>先不着急，部署之前还需要修改配置和安装部署插件。<br>第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz2srao2z2j20f104ewey.jpg" alt="image"></p><p>第二：要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： https://你的用户名.github.io 就会看到你的博客啦！！</p><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> 官网。<br>新建文章，输入以下命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">'文章标题'</span></span><br></pre></td></tr></table></figure></p><p>执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。</p><p>在 Markdown 文章里面输入你的文章内容</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz5x2qhmzbj216e0c50us.jpg" alt="image"></p><p>再执行一下以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以看到你的文章在博客显示了，以下就是刚刚</p><p><img src="https://wx1.sinaimg.cn/large/889d1a94gy1fz5x6potcgj20vk0e10te.jpg" alt="image"></p><p>最后，只要部署到你的 Github 上就可以了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="静态图床"><a href="#静态图床" class="headerlink" title="静态图床"></a>静态图床</h2><p>文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是<a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules" target="_blank" rel="noopener">测试域名</a>不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。</p><p>可以去chrome网上应用商店下载一个叫<a href="https://chrome.google.com/webstore/detail/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/pinjkilghdfhnkibhcangnpmcpdpmehk?hl=zh-CN" target="_blank" rel="noopener">微博图床</a>的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz72py0lycj20nw0go40c.jpg" alt="image"></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题页</a>或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官网使用文档</a>说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。</p><h3 id="一、添加评论系统"><a href="#一、添加评论系统" class="headerlink" title=" 一、添加评论系统 "></a><strong> 一、添加评论系统 </strong></h3><p><strong><em> 注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置 </em></strong></p><p>添加 <a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a> 评论系统，打开 /themes/next/_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz5yqhmvbqj20x009dq5c.jpg" alt="image"></p><p>然后到 leanCloud <a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">登录</a>或者<a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册</a> 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz5ywov61yj20zj0ea777.jpg" alt="image"></p><h3 id="二、配置腾讯公益404页面"><a href="#二、配置腾讯公益404页面" class="headerlink" title=" 二、配置腾讯公益404页面 "></a><strong> 二、配置腾讯公益404页面 </strong></h3><ol><li>在博客根目录 /source 文件夹下创建404.html（具体内容见下图及代码）；</li><li>在 html 上方加入上面3行代码；</li></ol><p>腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图</p><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz5zivfhysj210n0cpq5c.jpg" alt="image"></p><p>上图最前面的那几行也要加进去哦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: <span class="literal">false</span></span><br><span class="line">title: <span class="string">"404"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这里放一下上面用到的几个js链接，来自腾讯公益404官方<a href="https://www.qq.com/404/" target="_blank" rel="noopener">接入文档</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/plain"</span> src=<span class="string">"http://www.qq.com/404/search_children.js"</span> charset=<span class="string">"utf-8"</span> homePageUrl=<span class="string">"https://pojian.xyz"</span> homePageName=<span class="string">"回到我的博客主页"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你也可以直接复制我 Github 上的<a href="https://github.com/webw3c/webw3c.github.io/blob/master/404.html" target="_blank" rel="noopener">404页面代码</a>，以下是我博客的预览效果。</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz5zpo960mj21hb0r5jxt.jpg" alt="image"></p><p>另外如果需要自定义个性化404页面的只要删除相应腾讯的JS，直接修改上面的 404.html 文件就可以了。</p><h3 id="三、添加字数统计和阅读时长"><a href="#三、添加字数统计和阅读时长" class="headerlink" title=" 三、添加字数统计和阅读时长 "></a><strong> 三、添加字数统计和阅读时长 </strong></h3><p>首先安装一个插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>接着博客根目录下的配置文件里添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span></span><br><span class="line">  time: <span class="literal">true</span></span><br><span class="line">  total_symbols: <span class="literal">true</span></span><br><span class="line">  total_time: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后到 next 主题的配置文件下开启 symbols_count_time 字段</p><p><img src="https://ws4.sinaimg.cn/large/889d1a94gy1fz7fsfyw5hj20rx05gt97.jpg" alt="image"></p><p>重启一下 hexo 就可以看到效果啦</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz7fu1u1l8j20vq08p75j.jpg" alt="image"></p><h3 id="四、开启fancybox"><a href="#四、开启fancybox" class="headerlink" title=" 四、开启fancybox "></a><strong> 四、开启fancybox </strong></h3><p>打开主题配置文件搜索 fancybox 设置为 true，另外，vendors 填上对应 CDN 地址即可开启</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7fy76s0uj20n50cimzp.jpg" alt="image"></p><h3 id="五、文章分享"><a href="#五、文章分享" class="headerlink" title=" 五、文章分享 "></a><strong> 五、文章分享 </strong></h3><p>百度分享有个 https 的坑，按网上的方法把文件放到自己的服务器是我以前在其他的网站上测试过是能使用的，但在 hexo 中却报错了，具体不清楚是什么原因，感觉可能是 hexo 版本的问题，因为有的人可以，有的人报和我一样的错误，忘记截图了。因为这个功能也没有十分需要，就不继续爬了。换了 <a href="https://github.com/overtrue/share.js" target="_blank" rel="noopener">share.js</a> 实现了同样的功能，具体可以看本文文末的效果。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>如果你感觉直接使用 github.io 的域名作为你的博客链接不够专业，不够程序员的话那么就购买一个域名解析绑定到你的博客，我也比较建议这样做。<br>我的是在阿里万网<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.17.365b4f157s4Od7" target="_blank" rel="noopener">注册</a>的，注册流程比较常规这里就不多详述了，</p><p>注册登录控制台后找到你的域名，点右侧的解析按钮进去解析列表</p><p><img src="https://wx1.sinaimg.cn/large/889d1a94gy1fz68md161tj21hc0f3q6e.jpg" alt="image"><br><img src="http://wx3.sinaimg.cn/large/889d1a94gy1fz68pz0zjuj21fw0dtwgt.jpg" alt="image"></p><p>点右边的“添加记录”添加两条 CNAME 类型的记录，如上图，后面的记录值就填写你们自己的 Github 地址哈</p><p>记录添加完后就要到 <a href="https://www.github.com" target="_blank" rel="noopener">Github</a> 设置绑定你购买的域名了，进入你的博客仓库点 Setting，然后拉到 GitHub Pages 那里填上你的申请购买的域名保存就可以了</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz68xr3w2fj20sf05xgmd.jpg" alt="image"><br><img src="https://ws4.sinaimg.cn/large/889d1a94gy1fz68zmvj8ij20l90i5gny.jpg" alt="image"></p><p>这里说下，当你点击保存的时候 Github Pages 会自动帮你生成一个 CNAME 的文件在根目录，里面的内容就是你绑定的域名地址</p><p><img src="https://wx1.sinaimg.cn/large/889d1a94gy1fz694nu6n0j20tp0a4abc.jpg" alt="image"></p><p>注意，如果是按上面的方法操作还会有一点小问题，就是当你执行 hexo d 部署你本地的文章到 Github 时，你本地的文件会全部覆盖掉你现有仓库上的所有内容，包括 Github Pages 帮你创建的那个 CNAME 文件，这样的话当你访问域名的时候又会访问不到了。所以呢，你需要自己手动在本地根目录 /source 目录下手动创建一个 CNAME 文件，内容就是你的域名地址，因为 source 目录下的文件部署的时候是不会被删除的，所以部署的时候也会一起被部署上去，最后还需要重新到你仓库 Setting，拉到 GitHub Pages 那里再一次绑定你的域名，这样以后就没问题了。</p><p>稍等一会就可以用你申请的域名就访问你的博客了！</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>接下来说下百度收录，据说 Github 屏蔽了百度的蜘蛛，也有的人说没，具体不是很清楚，Github 在2015的时候遭受了史上最大规模的DDoS攻击，有国外媒体指百度干的，具体不得而知啦，但感觉百度收录 Github 确认是比较难，时间也比较长，所以还是优化一下吧。</p><h3 id="一、代码同时部署到-coding"><a href="#一、代码同时部署到-coding" class="headerlink" title="一、代码同时部署到 coding"></a>一、代码同时部署到 coding</h3><p>那有什么方法呢？就是把博客站点同时托管在国内的 coding 平台上，这样收录就会容易很多，同时又不影响 Github 上的代码，<a href="https://coding.net/" target="_blank" rel="noopener">coding</a> 是国内的一个提供代码托管服务的平台，跟 Github 差不多。使用方法也和 Github 差不多，下面我就具体说一下怎么把代码同时部署到 coding 和 Github 上面，让百度更容易收录。</p><p><a href="https://coding.net/register" target="_blank" rel="noopener">注册</a>、<a href="https://coding.net/login" target="_blank" rel="noopener">登录</a> coding 后创建一个新的仓库，注意点就是新建项目的时候命名规则和 Github 上的一样，就是 <strong>用户名.coding.me</strong> 可以看下图，还有记得别忘了添加 SSH key</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz78hhe593j20qw05dmxe.jpg" alt="image"></p><p>仓库建好后进入仓库，选左侧的 Page 服务，在设置中绑定新的域名，输入后点击绑定就可以了</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz78v08sssj21fn0ppgrv.jpg" alt="image"></p><p>接着到你的域名解析控制台修改添加两条 CNAME 记录指向你的 Page 地址，看下图，注意看记录值哦，换成你自己的。</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz78yh3racj21ay0czgnm.jpg" alt="image"></p><p>最后呢修改根目录下的 _config.yml 配置文件中的部署配置，把 coding 的 git 地址添加进去就行了</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz793dwgpfj20p005paak.jpg" alt="image"></p><p>最后执行部署命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>这时就可以在 coding 仓库中看到你提交部署的代码了，同时 你的用户名.coding.me 也可以访问你的博客站点了，这里 Github 和 coding 的代码是同时更新的，互不影响。而绑定的域名解析可能需要稍等一会才会生效。</p><h3 id="二、百度提交链接"><a href="#二、百度提交链接" class="headerlink" title="二、百度提交链接"></a>二、百度提交链接</h3><p>部署到 coding 后也不是百度就可以收录的，我们还需要继续优化。如果在百度搜索输入 site:你的域名 如果出现以下的效果证明就是网站还没被百度收录的，我们现在点下面的<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">提交网址</a>，进入百度站长工具提交。</p><p><img src="https://wx4.sinaimg.cn/large/889d1a94gy1fz7a9r2nifj20w209x0ty.jpg" alt="image"></p><h3 id="三、百度站长平台添加网站管理"><a href="#三、百度站长平台添加网站管理" class="headerlink" title="三、百度站长平台添加网站管理"></a>三、百度站长平台添加网站管理</h3><p>注册<a href="https://ziyuan.baidu.com/site/" target="_blank" rel="noopener">百度站长</a>工具，并添加网站</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7amrsnmoj20ym0aeabo.jpg" alt="image"></p><p>添加网站的过程有三步，主要操作集中在最后一步的网站验证方式里，我选择的是 HTML标签验证，按下面使用方法添加代码到你的网站即可</p><p><img src="https://ws2.sinaimg.cn/large/889d1a94gy1fz7atp67kej20s70l2tav.jpg" alt="image"></p><p>而使用 next 主题的同学可以直接在主题的配置文件下搜索 baidu_site_verification 后面填上第三步中 meta 标签中 content 的值就可以</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz7aydsnr6j20rz0asn02.jpg" alt="image"></p><p>最后点完成验证就可以通过了。</p><h3 id="四、添加sitemap站点地图"><a href="#四、添加sitemap站点地图" class="headerlink" title="四、添加sitemap站点地图"></a>四、添加sitemap站点地图</h3><p>站点地图包含了你网站上的站点链接，方便搜索引擎蜘蛛的抓取工作，搜索蜘蛛会通过网站地图中链接的深层次爬行，抓取新的内容。所以我们要生成 sitemap 文件助于网站优化，安装生成插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>接着在博客根目录下的配置文件里添加对应配置项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sitemap</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>注意缩进，要不会编译报错</p><p>还要修改一个根目录配置文件下的URL，url 一项的值改成你在百度站长平台里面添加的自己站点的地址，这样生成的 sitemap.xml 文件里的 url 才是你站点的地址，看下图</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7cay1xf9j20qc03wjrs.jpg" alt="image"></p><h3 id="五、添加蜘蛛协议robots-txt"><a href="#五、添加蜘蛛协议robots-txt" class="headerlink" title="五、添加蜘蛛协议robots.txt"></a>五、添加蜘蛛协议robots.txt</h3><p>增加 robots.txt 文件，就是蜘蛛协议，新建 robots.txt 文件添加以下内容，把 robots.txt 放在 /source 文件下，我们前面说过 /source 目录下的文件是会被打包上传的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo robots.txt</span></span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://pojian.xyz/sitemap.xml</span><br><span class="line">Sitemap: https://pojian.xyz/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow后面的就是你的menu，还有最下面的 Sitemap 地址请自行改成你们自己的地址</p><p>完成后，重启hexo，执行 hexo g -d 重新生成文件并提交后，在public目录下会生成对应的xml文件。可以通过 <a href="http://xxx.com/sitemap.xml" target="_blank" rel="noopener">http://xxx.com/sitemap.xml</a> 和 <a href="http://xxx.com/baidusitemap.xml" target="_blank" rel="noopener">http://xxx.com/baidusitemap.xml</a> 访问到 sitemap 文件，通过 <a href="http://xxx.com/robots.txt" target="_blank" rel="noopener">http://xxx.com/robots.txt</a> 访问到 robots.txt 文件。</p><p>可以到百度站长检测一下 robots.txt 文件是否生效</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz7df4tdohj210m0pnag3.jpg" alt="image"></p><h3 id="六、自动推送"><a href="#六、自动推送" class="headerlink" title="六、自动推送"></a>六、自动推送</h3><p>百度有自动推送、主动推送、sitemap、手动提交几种方式。<br>自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。怎么安装呢？<br>如果你的是 next 主题，只要打开主题配置文件搜索找到 baidu_push 设置为 true 即可</p><p><img src="https://ws1.sinaimg.cn/large/889d1a94gy1fz7ee6cn1hj20s001hglo.jpg" alt="image"></p><p>如果你使用的不是 next 主题，也可以手动把以下代码粘贴到你的站点，一般放在 head 头部公共文件里面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var bp = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">    var curProtocol = window.location.protocol.split(<span class="string">':'</span>)[0];</span><br><span class="line">    <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span><br><span class="line">        bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    var s = document.getElementsByTagName(<span class="string">"script"</span>)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="七、主动推送"><a href="#七、主动推送" class="headerlink" title="七、主动推送"></a>七、主动推送</h3><p>这里利用一个第三方插件 <a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">hexo-baidu-url-submit</a> 进行主动推送<br>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>添加想关配置到根目录下的配置文件里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度链接提交-主动推送配置</span></span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3 <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  host: pojian.xyz <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  token: 3GIEYsuq5ZTkvDBm <span class="comment">## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  path: baidu_urls.txt <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>添加新的部署配置，注意这里跟之前有点不一样，要在 type 前添加一个破折号 -</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - <span class="built_in">type</span>: git</span><br><span class="line">    repo:</span><br><span class="line">      github: https://github.com/webw3c/webw3c.github.io.git</span><br><span class="line">      coding: https://git.dev.tencent.com/yusting/yusting.coding.me.git</span><br><span class="line">  - <span class="built_in">type</span>: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>最后，执行 hexo deploy 的时候，新的连接就会被推送了。<br><strong> 实现原理 </strong><br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="八、手动推送"><a href="#八、手动推送" class="headerlink" title="八、手动推送"></a>八、手动推送</h3><p>就是直接直接把你需要提交的链接直接使用手动的方式填写提交就可以。</p><p>最后你可以看到是否已经被百度成功收录了</p><p><img src="https://wx3.sinaimg.cn/large/889d1a94gy1fz7eumo8agj20ti0nkaez.jpg" alt="image"></p><p>如果抓取成功了就证明已经被收录了，好像一般不会这么快，我的等了两天左右才抓取得到。</p><h3 id="九、添加百度统计"><a href="#九、添加百度统计" class="headerlink" title="九、添加百度统计"></a>九、添加百度统计</h3><p>添加<a href="https://tongji.baidu.com/web/homepage/index" target="_blank" rel="noopener">百度统计</a>就可以查看你网站相关的一些数据，便于你自己的站点</p><p><img src="https://ws3.sinaimg.cn/large/889d1a94gy1fz7f4xv3w1j21hc0cx79q.jpg" alt="image"></p><p><img src="https://wx2.sinaimg.cn/large/889d1a94gy1fz7f64cwx8j21h00ec79e.jpg" alt="image"></p><h2 id="多端同步写作"><a href="#多端同步写作" class="headerlink" title="多端同步写作"></a>多端同步写作</h2><p>内容准备中…</p><h2 id="手机编写"><a href="#手机编写" class="headerlink" title="手机编写"></a>手机编写</h2><p>网上好像找不到什么资料，不过通过在手机端安装 SSH 客户端远程操作服务器端，安装配置 node / git / hexo 环境编写应该可以的，原理同多台电脑编写差不多，不过这样做不太省心，不折腾了哈。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章到这差不多啦！后续有些小点深入学习后还是会保持更新的，希望文章对曾经像我一样的小白有那么一点帮助，技术有限，难免有纰漏，欢迎指正批评和讨论，感谢阅读！:-)</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Page </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
